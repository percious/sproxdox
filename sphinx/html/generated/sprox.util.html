<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>sprox.util &mdash; Sprox v0.5 documentation</title>
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
          URL_ROOT:    '../',
          VERSION:     '0.5',
          COLLAPSE_MODINDEX: false,
          FILE_SUFFIX: '.html'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="top" title="Sprox v0.5 documentation" href="../index.html" />
    <link rel="prev" title="sprox.widgets" href="sprox.widgets.html" />
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../modindex.html" title="Global Module Index"
             accesskey="M">modules</a> |</li>
        <li class="right" >
          <a href="sprox.widgets.html" title="sprox.widgets"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">Sprox v0.5 documentation</a> &raquo;</li>
      </ul>
    </div>
    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  
  <div class="section" id="module-sprox.util">
<h1><tt class="xref docutils literal"><span class="pre">sprox.util</span></tt><a class="headerlink" href="#module-sprox.util" title="Permalink to this headline">¶</a></h1>
<p>util Module</p>
<p>this contains the class which allows dbsprockets to interface with sqlalchemy.</p>
<p>Classes:
Name                               Description
MultiDict                          A class that allows dicts with multiple keys of the same value</p>
<p>Exceptions:
None</p>
<p>Functions:
None</p>
<p>Copywrite (c) 2007 Christopher Perkins
Original Version by Christopher Perkins 2007
Released under MIT license.</p>
<div class="section" id="functions">
<h2>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="sprox.util.freshdefaults">
<!--[sprox.util.freshdefaults]--><tt class="descclassname">sprox.util.</tt><tt class="descname">freshdefaults</tt><big>(</big><em>f</em><big>)</big><a class="headerlink" href="#sprox.util.freshdefaults" title="Permalink to this definition">¶</a></dt>
<dd>wrap f and keep its default values fresh between calls</dd></dl>

</div>
<div class="section" id="classes">
<h2>Classes<a class="headerlink" href="#classes" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="sprox.util.Label">
<!--[sprox.util.Label]-->class <tt class="descclassname">sprox.util.</tt><tt class="descname">Label</tt><a class="headerlink" href="#sprox.util.Label" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a title="(in Python v2.7)" class="reference external" href="http://docs.python.org/dev/library/functions.html#unicode"><tt class="xref docutils literal"><span class="pre">unicode</span></tt></a></p>
<p>use original attribute for passing references objects</p>
<dl class="method">
<dt id="sprox.util.Label.capitalize">
<!--[sprox.util.Label.capitalize]--><tt class="descname">capitalize</tt><big>(</big><big>)</big><a class="headerlink" href="#sprox.util.Label.capitalize" title="Permalink to this definition">¶</a></dt>
<dd><p>S.capitalize() -&gt; unicode</p>
<p>Return a capitalized version of S, i.e. make the first character
have upper case.</p>
</dd></dl>

<dl class="method">
<dt id="sprox.util.Label.center">
<!--[sprox.util.Label.center]--><tt class="descname">center</tt><big>(</big><big>)</big><a class="headerlink" href="#sprox.util.Label.center" title="Permalink to this definition">¶</a></dt>
<dd><p>S.center(width[, fillchar]) -&gt; unicode</p>
<p>Return S centered in a Unicode string of length width. Padding is
done using the specified fill character (default is a space)</p>
</dd></dl>

<dl class="method">
<dt id="sprox.util.Label.count">
<!--[sprox.util.Label.count]--><tt class="descname">count</tt><big>(</big><big>)</big><a class="headerlink" href="#sprox.util.Label.count" title="Permalink to this definition">¶</a></dt>
<dd><p>S.count(sub[, start[, end]]) -&gt; int</p>
<p>Return the number of non-overlapping occurrences of substring sub in
Unicode string S[start:end].  Optional arguments start and end are
interpreted as in slice notation.</p>
</dd></dl>

<dl class="method">
<dt id="sprox.util.Label.decode">
<!--[sprox.util.Label.decode]--><tt class="descname">decode</tt><big>(</big><big>)</big><a class="headerlink" href="#sprox.util.Label.decode" title="Permalink to this definition">¶</a></dt>
<dd><p>S.decode([encoding[,errors]]) -&gt; string or unicode</p>
<p>Decodes S using the codec registered for encoding. encoding defaults
to the default encoding. errors may be given to set a different error
handling scheme. Default is &#8216;strict&#8217; meaning that encoding errors raise
a UnicodeDecodeError. Other possible values are &#8216;ignore&#8217; and &#8216;replace&#8217;
as well as any other name registerd with codecs.register_error that is
able to handle UnicodeDecodeErrors.</p>
</dd></dl>

<dl class="method">
<dt id="sprox.util.Label.encode">
<!--[sprox.util.Label.encode]--><tt class="descname">encode</tt><big>(</big><big>)</big><a class="headerlink" href="#sprox.util.Label.encode" title="Permalink to this definition">¶</a></dt>
<dd><p>S.encode([encoding[,errors]]) -&gt; string or unicode</p>
<p>Encodes S using the codec registered for encoding. encoding defaults
to the default encoding. errors may be given to set a different error
handling scheme. Default is &#8216;strict&#8217; meaning that encoding errors raise
a UnicodeEncodeError. Other possible values are &#8216;ignore&#8217;, &#8216;replace&#8217; and
&#8216;xmlcharrefreplace&#8217; as well as any other name registered with
codecs.register_error that can handle UnicodeEncodeErrors.</p>
</dd></dl>

<dl class="method">
<dt id="sprox.util.Label.endswith">
<!--[sprox.util.Label.endswith]--><tt class="descname">endswith</tt><big>(</big><big>)</big><a class="headerlink" href="#sprox.util.Label.endswith" title="Permalink to this definition">¶</a></dt>
<dd><p>S.endswith(suffix[, start[, end]]) -&gt; bool</p>
<p>Return True if S ends with the specified suffix, False otherwise.
With optional start, test S beginning at that position.
With optional end, stop comparing S at that position.
suffix can also be a tuple of strings to try.</p>
</dd></dl>

<dl class="method">
<dt id="sprox.util.Label.expandtabs">
<!--[sprox.util.Label.expandtabs]--><tt class="descname">expandtabs</tt><big>(</big><big>)</big><a class="headerlink" href="#sprox.util.Label.expandtabs" title="Permalink to this definition">¶</a></dt>
<dd><p>S.expandtabs([tabsize]) -&gt; unicode</p>
<p>Return a copy of S where all tab characters are expanded using spaces.
If tabsize is not given, a tab size of 8 characters is assumed.</p>
</dd></dl>

<dl class="method">
<dt id="sprox.util.Label.find">
<!--[sprox.util.Label.find]--><tt class="descname">find</tt><big>(</big><big>)</big><a class="headerlink" href="#sprox.util.Label.find" title="Permalink to this definition">¶</a></dt>
<dd><p>S.find(sub [,start [,end]]) -&gt; int</p>
<p>Return the lowest index in S where substring sub is found,
such that sub is contained within s[start:end].  Optional
arguments start and end are interpreted as in slice notation.</p>
<p>Return -1 on failure.</p>
</dd></dl>

<dl class="method">
<dt id="sprox.util.Label.index">
<!--[sprox.util.Label.index]--><tt class="descname">index</tt><big>(</big><big>)</big><a class="headerlink" href="#sprox.util.Label.index" title="Permalink to this definition">¶</a></dt>
<dd><p>S.index(sub [,start [,end]]) -&gt; int</p>
<p>Like S.find() but raise ValueError when the substring is not found.</p>
</dd></dl>

<dl class="method">
<dt id="sprox.util.Label.isalnum">
<!--[sprox.util.Label.isalnum]--><tt class="descname">isalnum</tt><big>(</big><big>)</big><a class="headerlink" href="#sprox.util.Label.isalnum" title="Permalink to this definition">¶</a></dt>
<dd><p>S.isalnum() -&gt; bool</p>
<p>Return True if all characters in S are alphanumeric
and there is at least one character in S, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="sprox.util.Label.isalpha">
<!--[sprox.util.Label.isalpha]--><tt class="descname">isalpha</tt><big>(</big><big>)</big><a class="headerlink" href="#sprox.util.Label.isalpha" title="Permalink to this definition">¶</a></dt>
<dd><p>S.isalpha() -&gt; bool</p>
<p>Return True if all characters in S are alphabetic
and there is at least one character in S, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="sprox.util.Label.isdecimal">
<!--[sprox.util.Label.isdecimal]--><tt class="descname">isdecimal</tt><big>(</big><big>)</big><a class="headerlink" href="#sprox.util.Label.isdecimal" title="Permalink to this definition">¶</a></dt>
<dd><p>S.isdecimal() -&gt; bool</p>
<p>Return True if there are only decimal characters in S,
False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="sprox.util.Label.isdigit">
<!--[sprox.util.Label.isdigit]--><tt class="descname">isdigit</tt><big>(</big><big>)</big><a class="headerlink" href="#sprox.util.Label.isdigit" title="Permalink to this definition">¶</a></dt>
<dd><p>S.isdigit() -&gt; bool</p>
<p>Return True if all characters in S are digits
and there is at least one character in S, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="sprox.util.Label.islower">
<!--[sprox.util.Label.islower]--><tt class="descname">islower</tt><big>(</big><big>)</big><a class="headerlink" href="#sprox.util.Label.islower" title="Permalink to this definition">¶</a></dt>
<dd><p>S.islower() -&gt; bool</p>
<p>Return True if all cased characters in S are lowercase and there is
at least one cased character in S, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="sprox.util.Label.isnumeric">
<!--[sprox.util.Label.isnumeric]--><tt class="descname">isnumeric</tt><big>(</big><big>)</big><a class="headerlink" href="#sprox.util.Label.isnumeric" title="Permalink to this definition">¶</a></dt>
<dd><p>S.isnumeric() -&gt; bool</p>
<p>Return True if there are only numeric characters in S,
False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="sprox.util.Label.isspace">
<!--[sprox.util.Label.isspace]--><tt class="descname">isspace</tt><big>(</big><big>)</big><a class="headerlink" href="#sprox.util.Label.isspace" title="Permalink to this definition">¶</a></dt>
<dd><p>S.isspace() -&gt; bool</p>
<p>Return True if all characters in S are whitespace
and there is at least one character in S, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="sprox.util.Label.istitle">
<!--[sprox.util.Label.istitle]--><tt class="descname">istitle</tt><big>(</big><big>)</big><a class="headerlink" href="#sprox.util.Label.istitle" title="Permalink to this definition">¶</a></dt>
<dd><p>S.istitle() -&gt; bool</p>
<p>Return True if S is a titlecased string and there is at least one
character in S, i.e. upper- and titlecase characters may only
follow uncased characters and lowercase characters only cased ones.
Return False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="sprox.util.Label.isupper">
<!--[sprox.util.Label.isupper]--><tt class="descname">isupper</tt><big>(</big><big>)</big><a class="headerlink" href="#sprox.util.Label.isupper" title="Permalink to this definition">¶</a></dt>
<dd><p>S.isupper() -&gt; bool</p>
<p>Return True if all cased characters in S are uppercase and there is
at least one cased character in S, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="sprox.util.Label.join">
<!--[sprox.util.Label.join]--><tt class="descname">join</tt><big>(</big><big>)</big><a class="headerlink" href="#sprox.util.Label.join" title="Permalink to this definition">¶</a></dt>
<dd><p>S.join(sequence) -&gt; unicode</p>
<p>Return a string which is the concatenation of the strings in the
sequence.  The separator between elements is S.</p>
</dd></dl>

<dl class="method">
<dt id="sprox.util.Label.ljust">
<!--[sprox.util.Label.ljust]--><tt class="descname">ljust</tt><big>(</big><big>)</big><a class="headerlink" href="#sprox.util.Label.ljust" title="Permalink to this definition">¶</a></dt>
<dd><p>S.ljust(width[, fillchar]) -&gt; int</p>
<p>Return S left justified in a Unicode string of length width. Padding is
done using the specified fill character (default is a space).</p>
</dd></dl>

<dl class="method">
<dt id="sprox.util.Label.lower">
<!--[sprox.util.Label.lower]--><tt class="descname">lower</tt><big>(</big><big>)</big><a class="headerlink" href="#sprox.util.Label.lower" title="Permalink to this definition">¶</a></dt>
<dd><p>S.lower() -&gt; unicode</p>
<p>Return a copy of the string S converted to lowercase.</p>
</dd></dl>

<dl class="method">
<dt id="sprox.util.Label.lstrip">
<!--[sprox.util.Label.lstrip]--><tt class="descname">lstrip</tt><big>(</big><big>)</big><a class="headerlink" href="#sprox.util.Label.lstrip" title="Permalink to this definition">¶</a></dt>
<dd><p>S.lstrip([chars]) -&gt; unicode</p>
<p>Return a copy of the string S with leading whitespace removed.
If chars is given and not None, remove characters in chars instead.
If chars is a str, it will be converted to unicode before stripping</p>
</dd></dl>

<dl class="method">
<dt id="sprox.util.Label.partition">
<!--[sprox.util.Label.partition]--><tt class="descname">partition</tt><big>(</big><big>)</big><a class="headerlink" href="#sprox.util.Label.partition" title="Permalink to this definition">¶</a></dt>
<dd><p>S.partition(sep) -&gt; (head, sep, tail)</p>
<p>Searches for the separator sep in S, and returns the part before it,
the separator itself, and the part after it.  If the separator is not
found, returns S and two empty strings.</p>
</dd></dl>

<dl class="method">
<dt id="sprox.util.Label.replace">
<!--[sprox.util.Label.replace]--><tt class="descname">replace</tt><big>(</big><big>)</big><a class="headerlink" href="#sprox.util.Label.replace" title="Permalink to this definition">¶</a></dt>
<dd><p>S.replace (old, new[, maxsplit]) -&gt; unicode</p>
<p>Return a copy of S with all occurrences of substring
old replaced by new.  If the optional argument maxsplit is
given, only the first maxsplit occurrences are replaced.</p>
</dd></dl>

<dl class="method">
<dt id="sprox.util.Label.rfind">
<!--[sprox.util.Label.rfind]--><tt class="descname">rfind</tt><big>(</big><big>)</big><a class="headerlink" href="#sprox.util.Label.rfind" title="Permalink to this definition">¶</a></dt>
<dd><p>S.rfind(sub [,start [,end]]) -&gt; int</p>
<p>Return the highest index in S where substring sub is found,
such that sub is contained within s[start:end].  Optional
arguments start and end are interpreted as in slice notation.</p>
<p>Return -1 on failure.</p>
</dd></dl>

<dl class="method">
<dt id="sprox.util.Label.rindex">
<!--[sprox.util.Label.rindex]--><tt class="descname">rindex</tt><big>(</big><big>)</big><a class="headerlink" href="#sprox.util.Label.rindex" title="Permalink to this definition">¶</a></dt>
<dd><p>S.rindex(sub [,start [,end]]) -&gt; int</p>
<p>Like S.rfind() but raise ValueError when the substring is not found.</p>
</dd></dl>

<dl class="method">
<dt id="sprox.util.Label.rjust">
<!--[sprox.util.Label.rjust]--><tt class="descname">rjust</tt><big>(</big><big>)</big><a class="headerlink" href="#sprox.util.Label.rjust" title="Permalink to this definition">¶</a></dt>
<dd><p>S.rjust(width[, fillchar]) -&gt; unicode</p>
<p>Return S right justified in a Unicode string of length width. Padding is
done using the specified fill character (default is a space).</p>
</dd></dl>

<dl class="method">
<dt id="sprox.util.Label.rpartition">
<!--[sprox.util.Label.rpartition]--><tt class="descname">rpartition</tt><big>(</big><big>)</big><a class="headerlink" href="#sprox.util.Label.rpartition" title="Permalink to this definition">¶</a></dt>
<dd><p>S.rpartition(sep) -&gt; (tail, sep, head)</p>
<p>Searches for the separator sep in S, starting at the end of S, and returns
the part before it, the separator itself, and the part after it.  If the
separator is not found, returns two empty strings and S.</p>
</dd></dl>

<dl class="method">
<dt id="sprox.util.Label.rsplit">
<!--[sprox.util.Label.rsplit]--><tt class="descname">rsplit</tt><big>(</big><big>)</big><a class="headerlink" href="#sprox.util.Label.rsplit" title="Permalink to this definition">¶</a></dt>
<dd><p>S.rsplit([sep [,maxsplit]]) -&gt; list of strings</p>
<p>Return a list of the words in S, using sep as the
delimiter string, starting at the end of the string and
working to the front.  If maxsplit is given, at most maxsplit
splits are done. If sep is not specified, any whitespace string
is a separator.</p>
</dd></dl>

<dl class="method">
<dt id="sprox.util.Label.rstrip">
<!--[sprox.util.Label.rstrip]--><tt class="descname">rstrip</tt><big>(</big><big>)</big><a class="headerlink" href="#sprox.util.Label.rstrip" title="Permalink to this definition">¶</a></dt>
<dd><p>S.rstrip([chars]) -&gt; unicode</p>
<p>Return a copy of the string S with trailing whitespace removed.
If chars is given and not None, remove characters in chars instead.
If chars is a str, it will be converted to unicode before stripping</p>
</dd></dl>

<dl class="method">
<dt id="sprox.util.Label.split">
<!--[sprox.util.Label.split]--><tt class="descname">split</tt><big>(</big><big>)</big><a class="headerlink" href="#sprox.util.Label.split" title="Permalink to this definition">¶</a></dt>
<dd><p>S.split([sep [,maxsplit]]) -&gt; list of strings</p>
<p>Return a list of the words in S, using sep as the
delimiter string.  If maxsplit is given, at most maxsplit
splits are done. If sep is not specified or is None,
any whitespace string is a separator.</p>
</dd></dl>

<dl class="method">
<dt id="sprox.util.Label.splitlines">
<!--[sprox.util.Label.splitlines]--><tt class="descname">splitlines</tt><big>(</big><big>)</big><a class="headerlink" href="#sprox.util.Label.splitlines" title="Permalink to this definition">¶</a></dt>
<dd><p>S.splitlines([keepends]]) -&gt; list of strings</p>
<p>Return a list of the lines in S, breaking at line boundaries.
Line breaks are not included in the resulting list unless keepends
is given and true.</p>
</dd></dl>

<dl class="method">
<dt id="sprox.util.Label.startswith">
<!--[sprox.util.Label.startswith]--><tt class="descname">startswith</tt><big>(</big><big>)</big><a class="headerlink" href="#sprox.util.Label.startswith" title="Permalink to this definition">¶</a></dt>
<dd><p>S.startswith(prefix[, start[, end]]) -&gt; bool</p>
<p>Return True if S starts with the specified prefix, False otherwise.
With optional start, test S beginning at that position.
With optional end, stop comparing S at that position.
prefix can also be a tuple of strings to try.</p>
</dd></dl>

<dl class="method">
<dt id="sprox.util.Label.strip">
<!--[sprox.util.Label.strip]--><tt class="descname">strip</tt><big>(</big><big>)</big><a class="headerlink" href="#sprox.util.Label.strip" title="Permalink to this definition">¶</a></dt>
<dd><p>S.strip([chars]) -&gt; unicode</p>
<p>Return a copy of the string S with leading and trailing
whitespace removed.
If chars is given and not None, remove characters in chars instead.
If chars is a str, it will be converted to unicode before stripping</p>
</dd></dl>

<dl class="method">
<dt id="sprox.util.Label.swapcase">
<!--[sprox.util.Label.swapcase]--><tt class="descname">swapcase</tt><big>(</big><big>)</big><a class="headerlink" href="#sprox.util.Label.swapcase" title="Permalink to this definition">¶</a></dt>
<dd><p>S.swapcase() -&gt; unicode</p>
<p>Return a copy of S with uppercase characters converted to lowercase
and vice versa.</p>
</dd></dl>

<dl class="method">
<dt id="sprox.util.Label.title">
<!--[sprox.util.Label.title]--><tt class="descname">title</tt><big>(</big><big>)</big><a class="headerlink" href="#sprox.util.Label.title" title="Permalink to this definition">¶</a></dt>
<dd><p>S.title() -&gt; unicode</p>
<p>Return a titlecased version of S, i.e. words start with title case
characters, all remaining cased characters have lower case.</p>
</dd></dl>

<dl class="method">
<dt id="sprox.util.Label.translate">
<!--[sprox.util.Label.translate]--><tt class="descname">translate</tt><big>(</big><big>)</big><a class="headerlink" href="#sprox.util.Label.translate" title="Permalink to this definition">¶</a></dt>
<dd><p>S.translate(table) -&gt; unicode</p>
<p>Return a copy of the string S, where all characters have been mapped
through the given translation table, which must be a mapping of
Unicode ordinals to Unicode ordinals, Unicode strings or None.
Unmapped characters are left untouched. Characters mapped to None
are deleted.</p>
</dd></dl>

<dl class="method">
<dt id="sprox.util.Label.upper">
<!--[sprox.util.Label.upper]--><tt class="descname">upper</tt><big>(</big><big>)</big><a class="headerlink" href="#sprox.util.Label.upper" title="Permalink to this definition">¶</a></dt>
<dd><p>S.upper() -&gt; unicode</p>
<p>Return a copy of S converted to uppercase.</p>
</dd></dl>

<dl class="method">
<dt id="sprox.util.Label.zfill">
<!--[sprox.util.Label.zfill]--><tt class="descname">zfill</tt><big>(</big><big>)</big><a class="headerlink" href="#sprox.util.Label.zfill" title="Permalink to this definition">¶</a></dt>
<dd><p>S.zfill(width) -&gt; unicode</p>
<p>Pad a numeric string x with zeros on the left, to fill a field
of the specified width. The string x is never truncated.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sprox.util.MultiDict">
<!--[sprox.util.MultiDict]-->class <tt class="descclassname">sprox.util.</tt><tt class="descname">MultiDict</tt><a class="headerlink" href="#sprox.util.MultiDict" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a title="(in Python v2.7)" class="reference external" href="http://docs.python.org/dev/library/stdtypes.html#dict"><tt class="xref docutils literal"><span class="pre">dict</span></tt></a></p>
<dl class="method">
<dt id="sprox.util.MultiDict.clear">
<!--[sprox.util.MultiDict.clear]--><tt class="descname">clear</tt><big>(</big><big>)</big><a class="headerlink" href="#sprox.util.MultiDict.clear" title="Permalink to this definition">¶</a></dt>
<dd>D.clear() -&gt; None.  Remove all items from D.</dd></dl>

<dl class="method">
<dt id="sprox.util.MultiDict.copy">
<!--[sprox.util.MultiDict.copy]--><tt class="descname">copy</tt><big>(</big><big>)</big><a class="headerlink" href="#sprox.util.MultiDict.copy" title="Permalink to this definition">¶</a></dt>
<dd>D.copy() -&gt; a shallow copy of D</dd></dl>

<dl class="staticmethod">
<dt id="sprox.util.MultiDict.fromkeys">
<!--[sprox.util.MultiDict.fromkeys]--><em class="property">
static </em><tt class="descname">fromkeys</tt><big>(</big><big>)</big><a class="headerlink" href="#sprox.util.MultiDict.fromkeys" title="Permalink to this definition">¶</a></dt>
<dd>dict.fromkeys(S[,v]) -&gt; New dict with keys from S and values equal to v.
v defaults to None.</dd></dl>

<dl class="method">
<dt id="sprox.util.MultiDict.get">
<!--[sprox.util.MultiDict.get]--><tt class="descname">get</tt><big>(</big><big>)</big><a class="headerlink" href="#sprox.util.MultiDict.get" title="Permalink to this definition">¶</a></dt>
<dd>D.get(k[,d]) -&gt; D[k] if k in D, else d.  d defaults to None.</dd></dl>

<dl class="method">
<dt id="sprox.util.MultiDict.has_key">
<!--[sprox.util.MultiDict.has_key]--><tt class="descname">has_key</tt><big>(</big><big>)</big><a class="headerlink" href="#sprox.util.MultiDict.has_key" title="Permalink to this definition">¶</a></dt>
<dd>D.has_key(k) -&gt; True if D has a key k, else False</dd></dl>

<dl class="method">
<dt id="sprox.util.MultiDict.items">
<!--[sprox.util.MultiDict.items]--><tt class="descname">items</tt><big>(</big><big>)</big><a class="headerlink" href="#sprox.util.MultiDict.items" title="Permalink to this definition">¶</a></dt>
<dd>D.items() -&gt; list of D&#8217;s (key, value) pairs, as 2-tuples</dd></dl>

<dl class="method">
<dt id="sprox.util.MultiDict.iteritems">
<!--[sprox.util.MultiDict.iteritems]--><tt class="descname">iteritems</tt><big>(</big><big>)</big><a class="headerlink" href="#sprox.util.MultiDict.iteritems" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="sprox.util.MultiDict.iterkeys">
<!--[sprox.util.MultiDict.iterkeys]--><tt class="descname">iterkeys</tt><big>(</big><big>)</big><a class="headerlink" href="#sprox.util.MultiDict.iterkeys" title="Permalink to this definition">¶</a></dt>
<dd>D.iterkeys() -&gt; an iterator over the keys of D</dd></dl>

<dl class="method">
<dt id="sprox.util.MultiDict.itervalues">
<!--[sprox.util.MultiDict.itervalues]--><tt class="descname">itervalues</tt><big>(</big><big>)</big><a class="headerlink" href="#sprox.util.MultiDict.itervalues" title="Permalink to this definition">¶</a></dt>
<dd>D.itervalues() -&gt; an iterator over the values of D</dd></dl>

<dl class="method">
<dt id="sprox.util.MultiDict.keys">
<!--[sprox.util.MultiDict.keys]--><tt class="descname">keys</tt><big>(</big><big>)</big><a class="headerlink" href="#sprox.util.MultiDict.keys" title="Permalink to this definition">¶</a></dt>
<dd>D.keys() -&gt; list of D&#8217;s keys</dd></dl>

<dl class="method">
<dt id="sprox.util.MultiDict.pop">
<!--[sprox.util.MultiDict.pop]--><tt class="descname">pop</tt><big>(</big><big>)</big><a class="headerlink" href="#sprox.util.MultiDict.pop" title="Permalink to this definition">¶</a></dt>
<dd>D.pop(k[,d]) -&gt; v, remove specified key and return the corresponding value
If key is not found, d is returned if given, otherwise KeyError is raised</dd></dl>

<dl class="method">
<dt id="sprox.util.MultiDict.popitem">
<!--[sprox.util.MultiDict.popitem]--><tt class="descname">popitem</tt><big>(</big><big>)</big><a class="headerlink" href="#sprox.util.MultiDict.popitem" title="Permalink to this definition">¶</a></dt>
<dd>D.popitem() -&gt; (k, v), remove and return some (key, value) pair as a
2-tuple; but raise KeyError if D is empty</dd></dl>

<dl class="method">
<dt id="sprox.util.MultiDict.setdefault">
<!--[sprox.util.MultiDict.setdefault]--><tt class="descname">setdefault</tt><big>(</big><big>)</big><a class="headerlink" href="#sprox.util.MultiDict.setdefault" title="Permalink to this definition">¶</a></dt>
<dd>D.setdefault(k[,d]) -&gt; D.get(k,d), also set D[k]=d if k not in D</dd></dl>

<dl class="method">
<dt id="sprox.util.MultiDict.update">
<!--[sprox.util.MultiDict.update]--><tt class="descname">update</tt><big>(</big><big>)</big><a class="headerlink" href="#sprox.util.MultiDict.update" title="Permalink to this definition">¶</a></dt>
<dd>D.update(E, <a href="#id1"><span class="problematic" id="id2">**</span></a>F) -&gt; None.  Update D from E and F: for k in E: D[k] = E[k]
(if E has keys else: for (k, v) in E: D[k] = v) then: for k in F: D[k] = F[k]</dd></dl>

<dl class="method">
<dt id="sprox.util.MultiDict.values">
<!--[sprox.util.MultiDict.values]--><tt class="descname">values</tt><big>(</big><big>)</big><a class="headerlink" href="#sprox.util.MultiDict.values" title="Permalink to this definition">¶</a></dt>
<dd>D.values() -&gt; list of D&#8217;s values</dd></dl>

</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <h3><a href="../index.html">Table Of Contents</a></h3>
            <ul>
<li><a class="reference external" href=""><tt class="docutils literal"><span class="pre">sprox.util</span></tt></a><ul>
<li><a class="reference external" href="#functions">Functions</a></li>
<li><a class="reference external" href="#classes">Classes</a></li>
</ul>
</li>
</ul>

            <h4>Previous topic</h4>
            <p class="topless"><a href="sprox.widgets.html" title="previous chapter"><tt class="docutils literal"><span class="pre">sprox.widgets</span></tt></a></p>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="../_sources/generated/sprox.util.txt">Show Source</a></li>
            </ul>
          <h3>Quick search</h3>
            <form class="search" action="../search.html" method="get">
              <input type="text" name="q" size="18" /> <input type="submit" value="Go" />
              <input type="hidden" name="check_keywords" value="yes" />
              <input type="hidden" name="area" value="default" />
            </form>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../modindex.html" title="Global Module Index"
             accesskey="M">modules</a> |</li>
        <li class="right" >
          <a href="sprox.widgets.html" title="sprox.widgets"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">Sprox v0.5 documentation</a> &raquo;</li>
      </ul>
    </div>
    <div class="footer">
      &copy; Copyright 2008, Christopher Perkins.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 0.5.
    </div>
  </body>
</html>